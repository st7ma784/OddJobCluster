apiVersion: v1
kind: ConfigMap
metadata:
  name: android-task-server-code
  namespace: android-cluster
data:
  server.py: |
    #!/usr/bin/env python3
    """
    Android Cluster Coordinator
    WebSocket server for managing Android compute nodes
    """
    
    import asyncio
    import websockets
    import json
    import logging
    import time
    import subprocess
    import os
    from typing import Dict, List, Any, Optional
    from dataclasses import dataclass, asdict
    from datetime import datetime
    import uuid
    from aiohttp import web, web_response
    import aiohttp_cors
    
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    @dataclass
    class ComputeNode:
        node_id: str
        ip_address: str
        status: str = "disconnected"
        last_seen: float = 0
        tasks_completed: int = 0
        capabilities: List[str] = None
        performance_score: float = 0.0
        kubernetes_registered: bool = False
        slurm_registered: bool = False
        
        def __post_init__(self):
            if self.capabilities is None:
                self.capabilities = []
    
    @dataclass
    class ComputeTask:
        task_id: str
        task_type: str
        data: Dict[str, Any]
        priority: int = 1
        created_at: float = 0
        assigned_to: str = None
        status: str = "pending"
        result: Any = None
        
        def __post_init__(self):
            if self.created_at == 0:
                self.created_at = time.time()
    
    class ClusterCoordinator:
        def __init__(self):
            self.nodes: Dict[str, ComputeNode] = {}
            self.tasks: Dict[str, ComputeTask] = {}
            self.task_queue: List[str] = []
            self.connections: Dict[str, websockets.WebSocketServerProtocol] = {}
            self.kubernetes_available = self.check_kubernetes_cluster()
            self.slurm_available = self.check_slurm_cluster()
            self.munge_available = self.check_munge_service()
            
            if self.kubernetes_available:
                logger.info("✅ Kubernetes cluster detected - Android nodes will be auto-registered")
            if self.slurm_available:
                if self.munge_available:
                    logger.info("✅ SLURM cluster with MUNGE authentication detected - Android nodes will be auto-registered")
                else:
                    logger.warning("⚠️ SLURM cluster detected but MUNGE authentication is missing - registration may fail")
                    logger.info("💡 Install MUNGE: sudo apt-get install munge libmunge-dev")
        
        def check_kubernetes_cluster(self) -> bool:
            """Check if Kubernetes cluster is available on this host"""
            try:
                result = subprocess.run(['kubectl', 'cluster-info'], 
                                      capture_output=True, text=True, timeout=5)
                return result.returncode == 0
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return False
        
        def check_slurm_cluster(self) -> bool:
            """Check if SLURM cluster is available on this host"""
            try:
                result = subprocess.run(['sinfo', '--version'], 
                                      capture_output=True, text=True, timeout=5)
                return result.returncode == 0
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return False
        
        def check_munge_service(self) -> bool:
            """Check if MUNGE authentication service is available"""
            try:
                result = subprocess.run(['which', 'munge'], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode != 0:
                    return False
                
                test_result = subprocess.run(['bash', '-c', 'echo "test" | munge | unmunge'], 
                                           capture_output=True, text=True, timeout=10)
                return test_result.returncode == 0 and 'test' in test_result.stdout
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return False
        
        def add_task(self, task_type: str, data: Dict[str, Any], priority: int = 1) -> str:
            """Add a new task to the queue"""
            task_id = str(uuid.uuid4())
            task = ComputeTask(
                task_id=task_id,
                task_type=task_type,
                data=data,
                priority=priority
            )
            
            self.tasks[task_id] = task
            self.task_queue.append(task_id)
            self.task_queue.sort(key=lambda tid: self.tasks[tid].priority, reverse=True)
            
            logger.info(f"Added task {task_id} of type {task_type}")
            return task_id
        
        def get_cluster_status(self) -> Dict[str, Any]:
            """Get current cluster status including all nodes"""
            return {
                "android_nodes": {nid: asdict(node) for nid, node in self.nodes.items()},
                "kubernetes_nodes": [],
                "slurm_nodes": [],
                "tasks": {
                    "total": len(self.tasks),
                    "pending": len(self.task_queue),
                    "completed": len([t for t in self.tasks.values() if t.status == "completed"])
                },
                "clusters": {
                    "kubernetes": {
                        "available": self.kubernetes_available,
                        "registered_nodes": len([n for n in self.nodes.values() if n.kubernetes_registered]),
                        "total_nodes": 0
                    },
                    "slurm": {
                        "available": self.slurm_available,
                        "munge_available": self.munge_available,
                        "registered_nodes": len([n for n in self.nodes.values() if n.slurm_registered]),
                        "total_nodes": 0
                    }
                },
                "timestamp": time.time()
            }
    
    # Global coordinator instance
    coordinator = ClusterCoordinator()
    
    async def status_handler(request):
        """HTTP endpoint for cluster status"""
        status = coordinator.get_cluster_status()
        return web_response.json_response(status)
    
    async def submit_task_handler(request):
        """HTTP endpoint for custom task submission"""
        try:
            data = await request.json()
            task_type = data.get('task_type')
            task_data = data.get('data', {})
            priority = data.get('priority', 1)
            
            if not task_type:
                return web_response.json_response(
                    {'error': 'task_type is required'}, status=400)
            
            task_id = coordinator.add_task(task_type, task_data, priority)
            
            return web_response.json_response({
                'task_id': task_id,
                'status': 'submitted',
                'message': f'Task {task_id} submitted successfully'
            })
        except Exception as e:
            logger.error(f"Error submitting task: {e}")
            return web_response.json_response(
                {'error': str(e)}, status=500)
    
    async def main():
        """Start the cluster coordinator server"""
        logger.info("Starting Android Cluster Coordinator...")
        
        # Create HTTP app for dashboard and API
        app = web.Application()
        
        # Setup CORS
        cors = aiohttp_cors.setup(app, defaults={
            "*": aiohttp_cors.ResourceOptions(
                allow_credentials=True,
                expose_headers="*",
                allow_headers="*",
                allow_methods="*"
            )
        })
        
        # Add routes
        app.router.add_get('/status', status_handler)
        app.router.add_post('/submit_task', submit_task_handler)
        
        # Add CORS to all routes
        for route in list(app.router.routes()):
            cors.add(route)
        
        # Start HTTP server
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', 8766)
        await site.start()
        
        logger.info("✅ HTTP API available at http://0.0.0.0:8766")
        logger.info("🚀 Android Task Server running in Kubernetes")
        
        # Keep server running
        try:
            await asyncio.Future()  # run forever
        except KeyboardInterrupt:
            logger.info("Shutting down servers...")
            await runner.cleanup()
    
    if __name__ == "__main__":
        try:
            asyncio.run(main())
        except KeyboardInterrupt:
            logger.info("Server stopped by user")
